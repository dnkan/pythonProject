## Свой zip 2

# Напишите функцию, которая будет являться аналогом функции zip
# и сделайте так, чтобы программа работала с любыми итерируемыми
# типами данных.
#
# - Нельзя пользоваться циклами (за исключением генераторов),
#   условными операторами и функциями определения типа
#   (isinstance или type).
# - Функция должна возвращать список с кортежами, в котором
#   n-ый кортеж состоит из n-ых элементов всех последовательностей.
#   Например, десятый кортеж будет содержать десятый элемент каждой
#   из переданных последовательностей
# - Основной код оставьте пустым или закомментированным
#   (используйте его только для тестирования).
#
# Основной код оставьте пустым или закомментированным (используйте его только для тестирования).


def my_zip(*args):
    length = min(len(element) for element in args)
    new_list = [tuple(elem[i] for elem in map(list, args)) for i in range(length)]
    return new_list


a = [{"x": 4}, "b", "z", "d"]

b = (10, {20,}, [30], "z")

print(my_zip(a, b))  # -> [({‘x’: 4}, 10), (‘b’, {20}), (‘z’, [30]), (‘d’, ‘z’)]


a = [1, 2, 3, 4, 5]

b = {1: "s", 2: "q", 3: 4}

x = (1, 2, 3, 4, 5)

print(my_zip(a, b, x))  # -> [(1, 1, 1), (2, 2, 2), (3, 3, 3)]